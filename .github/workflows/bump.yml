name: Deploy API Documentation to Bump.sh

on:
  push:
    branches: [main]
    paths:
      - '**/*.yaml'
      - '**/*.yml'
  workflow_dispatch:

jobs:
  deploy-to-bump:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for better context

      - name: Setup Node.js v20
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Bump.sh CLI
        run: |
          npm install -g bump-cli
          pip install --user pyyaml

      - name: Consolidate OpenAPI files
        id: consolidate
        run: |
          echo "Creating consolidated OpenAPI file..."
          cat > resolve_refs.py << 'EOL'
          import yaml
          import os
          import sys
          from collections import OrderedDict
          from pathlib import Path

          # Make PyYAML use OrderedDict for mappings
          def ordered_load(stream, Loader=yaml.SafeLoader):
              class OrderedLoader(Loader):
                  pass
              def construct_mapping(loader, node):
                  loader.flatten_mapping(node)
                  return OrderedDict(loader.construct_pairs(node))
              OrderedLoader.add_constructor(
                  yaml.resolver.Resolver.DEFAULT_MAPPING_TAG,
                  construct_mapping)
              return yaml.load(stream, OrderedLoader)

          def ordered_dump(data, stream=None, Dumper=yaml.SafeDumper, **kwds):
              class OrderedDumper(Dumper):
                  pass
              def _dict_representer(dumper, data):
                  return dumper.represent_mapping(
                      yaml.resolver.Resolver.DEFAULT_MAPPING_TAG,
                      data.items())
              OrderedDumper.add_representer(OrderedDict, _dict_representer)
              return yaml.dump(data, stream, OrderedDumper, **kwds)

          def load_yaml_safely(file_path):
              """Load a YAML file with error handling"""
              try:
                  with open(file_path, 'r') as f:
                      return ordered_load(f)
              except Exception as e:
                  print(f"Error loading {file_path}: {str(e)}")
                  return None

          def resolve_refs(openapi_content, base_dir='.'):
              """Recursively resolve all $ref references"""
              if isinstance(openapi_content, OrderedDict):
                  # Create a new OrderedDict to avoid modifying while iterating
                  resolved_dict = OrderedDict()
                  for key, value in openapi_content.items():
                      if key == '$ref' and isinstance(value, str):
                          if value.startswith('#'):
                              # Internal reference, keep as is
                              resolved_dict[key] = value
                          else:
                              # External reference
                              try:
                                  # Split the reference into file path and internal reference
                                  parts = value.split('#', 1)
                                  file_path = parts[0]
                                  
                                  # Handle relative paths
                                  if file_path.startswith('./'):
                                      file_path = file_path[2:]
                                  
                                  # Combine with base directory
                                  full_path = os.path.join(base_dir, file_path)
                                  
                                  print(f"Resolving: {value}")
                                  
                                  # Load the referenced file
                                  ref_content = load_yaml_safely(full_path)
                                  if ref_content is None:
                                      print(f"Warning: Failed to resolve reference {value}")
                                      resolved_dict[key] = value  # Keep original reference
                                  else:
                                      # If there's an internal reference, extract it
                                      if len(parts) > 1 and parts[1]:
                                          ref_path = parts[1].lstrip('/')
                                          try:
                                              # Navigate through the referenced content
                                              ref_parts = ref_path.split('/')
                                              current = ref_content
                                              for part in ref_parts:
                                                  current = current[part]
                                              
                                              # Replace with resolved content
                                              return resolve_refs(current, os.path.dirname(full_path))
                                          except (KeyError, TypeError) as e:
                                              print(f"Warning: Failed to resolve path {ref_path} in {full_path}: {e}")
                                              resolved_dict[key] = value  # Keep original reference
                                      else:
                                          # Replace with entire file content
                                          return resolve_refs(ref_content, os.path.dirname(full_path))
                              except Exception as e:
                                  print(f"Warning: Error resolving reference {value}: {str(e)}")
                                  resolved_dict[key] = value  # Keep original reference
                      else:
                          # Recursively resolve nested references
                          resolved_dict[key] = resolve_refs(value, base_dir)
                  return resolved_dict
                  
              elif isinstance(openapi_content, list):
                  # Process lists recursively
                  return [resolve_refs(item, base_dir) for item in openapi_content]
              else:
                  # Return primitive values as is
                  return openapi_content

          def main():
              # Load main OpenAPI file
              print("Loading main OpenAPI file...")
              openapi = load_yaml_safely('openapi.yaml')
              if not openapi:
                  sys.exit(1)
              
              # Handle special case for x-topics separately
              if 'x-topics' in openapi:
                  if isinstance(openapi['x-topics'], OrderedDict) and '$ref' in openapi['x-topics']:
                      topics_ref = openapi['x-topics']['$ref']
                      print(f"Found x-topics reference: {topics_ref}")
                      
                      # Clean up the reference path
                      if topics_ref.startswith('./'):
                          topics_ref = topics_ref[2:]
                      
                      # Load topics file
                      topics = load_yaml_safely(topics_ref)
                      if topics:
                          print(f"Loaded topics file successfully")
                          openapi['x-topics'] = topics
                      else:
                          print("Error: Failed to load topics file")
              
              # Resolve other references
              print("Resolving references...")
              try:
                  resolved_openapi = resolve_refs(openapi)
                  
                  # Write the resolved content to a new file
                  with open('openapi-resolved.yaml', 'w') as f:
                      ordered_dump(resolved_openapi, f, default_flow_style=False, sort_keys=False)
                  
                  print("Successfully created openapi-resolved.yaml with preserved ordering")
                  
                  # Validate the resolved file is valid YAML
                  try:
                      with open('openapi-resolved.yaml', 'r') as f:
                          yaml.safe_load(f)
                      print("Verification: openapi-resolved.yaml is valid YAML")
                  except Exception as e:
                      print(f"Error: Generated file is not valid YAML: {str(e)}")
                      sys.exit(1)
                  
              except Exception as e:
                  print(f"Error: Failed to resolve references: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOL

          # Run the reference resolution script
          python3 resolve_refs.py

          # Print file size for verification
          echo "Original OpenAPI file size: $(wc -c openapi.yaml | awk '{print $1}') bytes"
          echo "Resolved OpenAPI file size: $(wc -c openapi-resolved.yaml | awk '{print $1}') bytes"

      - name: Deploy to Bump.sh
        id: deploy
        run: |
          echo "Deploying to Bump.sh..."
          output=$(bump deploy openapi-resolved.yaml --doc omni-v2)
          EXIT_CODE=$?

          echo "$output"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "Deployment successful!"
          else
            if echo "$output" | grep -q "Your omni-v2 documentation has not changed"; then
              echo "No changes detected in documentation. Skipping deployment."
              exit 0
            else
              echo "Deployment failed with exit code $EXIT_CODE"
              exit $EXIT_CODE
            fi
          fi
        env:
          BUMP_TOKEN: ${{ secrets.BUMP_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "* Source file: openapi.yaml ($(wc -c openapi.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Resolved file: openapi-resolved.yaml ($(wc -c openapi-resolved.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Status: ${{ steps.deploy.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View documentation at: https://bump.sh/doc/omni-v2" >> $GITHUB_STEP_SUMMARY
