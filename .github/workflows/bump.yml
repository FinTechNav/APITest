name: Deploy API Documentation to Bump.sh

on:
  push:
    branches: [main]
    paths:
      - '**/*.yaml'
      - '**/*.yml'
  workflow_dispatch: # Allow manual triggering

jobs:
  deploy-to-bump:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for better error context

      - name: Setup Node.js v20
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Bump.sh CLI and dependencies
        run: |
          echo "Installing required tools..."
          npm install -g bump-cli
          # Install spectral for validation
          npm install -g @stoplight/spectral-cli

          # Ensure Python YAML is available
          pip install pyyaml

      - name: Validate OpenAPI files
        id: validate
        continue-on-error: true
        run: |
          echo "Validating OpenAPI files..."
          # Check if main file exists
          if [ ! -f "openapi.yaml" ]; then
            echo "::error::Main OpenAPI file (openapi.yaml) not found!"
            exit 1
          fi

          # List all referenced files for diagnosis
          echo "Referenced YAML files:"
          grep -r "\$ref:" --include="*.yaml" --include="*.yml" . | sort

          # Basic structure validation with spectral
          echo "Running Spectral validation..."
          spectral lint openapi.yaml || echo "::warning::Spectral validation found issues - continuing anyway"

      - name: Resolve references with Python
        id: resolve_refs
        run: |
          echo "Creating consolidated OpenAPI file with Python..."
          cat > resolve_refs.py << 'EOL'
          import yaml
          import os
          import sys
          import re
          import json
          from pathlib import Path

          def find_yaml_files():
              """Find all YAML files in the current directory"""
              yaml_files = []
              for ext in ['*.yaml', '*.yml']:
                  yaml_files.extend(list(Path('.').glob(f'**/{ext}')))
              return [str(f) for f in yaml_files]

          def load_yaml_safely(file_path):
              """Load a YAML file with error handling"""
              try:
                  with open(file_path, 'r') as f:
                      return yaml.safe_load(f)
              except Exception as e:
                  print(f"::error::Error loading {file_path}: {str(e)}")
                  return None

          def resolve_refs(openapi_content, base_dir='.'):
              """Recursively resolve all $ref references"""
              if isinstance(openapi_content, dict):
                  # Create a new dict to avoid modifying while iterating
                  resolved_dict = {}
                  for key, value in openapi_content.items():
                      if key == '$ref' and isinstance(value, str):
                          if value.startswith('#'):
                              # Internal reference, keep as is
                              resolved_dict[key] = value
                          else:
                              # External reference
                              try:
                                  # Split the reference into file path and internal reference
                                  parts = value.split('#', 1)
                                  file_path = parts[0]
                                  
                                  # Handle relative paths
                                  if file_path.startswith('./'):
                                      file_path = file_path[2:]
                                  
                                  # Combine with base directory
                                  full_path = os.path.join(base_dir, file_path)
                                  
                                  print(f"Resolving external reference: {value} -> {full_path}")
                                  
                                  # Load the referenced file
                                  ref_content = load_yaml_safely(full_path)
                                  if ref_content is None:
                                      print(f"::warning::Failed to resolve reference {value}")
                                      resolved_dict[key] = value  # Keep original reference
                                  else:
                                      # If there's an internal reference, extract it
                                      if len(parts) > 1 and parts[1]:
                                          ref_path = parts[1].lstrip('/')
                                          try:
                                              # Navigate through the referenced content
                                              ref_parts = ref_path.split('/')
                                              current = ref_content
                                              for part in ref_parts:
                                                  current = current[part]
                                              
                                              # Replace with resolved content
                                              return resolve_refs(current, os.path.dirname(full_path))
                                          except (KeyError, TypeError) as e:
                                              print(f"::warning::Failed to resolve path {ref_path} in {full_path}: {e}")
                                              resolved_dict[key] = value  # Keep original reference
                                      else:
                                          # Replace with entire file content
                                          return resolve_refs(ref_content, os.path.dirname(full_path))
                              except Exception as e:
                                  print(f"::warning::Error resolving reference {value}: {str(e)}")
                                  resolved_dict[key] = value  # Keep original reference
                      else:
                          # Recursively resolve nested references
                          resolved_dict[key] = resolve_refs(value, base_dir)
                  return resolved_dict
                  
              elif isinstance(openapi_content, list):
                  # Process lists recursively
                  return [resolve_refs(item, base_dir) for item in openapi_content]
              else:
                  # Return primitive values as is
                  return openapi_content

          def main():
              # Load main OpenAPI file
              print("Loading main OpenAPI file...")
              openapi = load_yaml_safely('openapi.yaml')
              if not openapi:
                  sys.exit(1)
              
              # Handle special case for x-topics separately
              if 'x-topics' in openapi and isinstance(openapi['x-topics'], dict) and '$ref' in openapi['x-topics']:
                  topics_ref = openapi['x-topics']['$ref']
                  print(f"Found x-topics reference: {topics_ref}")
                  
                  # Clean up the reference path
                  if topics_ref.startswith('./'):
                      topics_ref = topics_ref[2:]
                  
                  # Load topics file
                  topics = load_yaml_safely(topics_ref)
                  if topics:
                      print(f"Loaded topics file with {len(topics)} topics")
                      openapi['x-topics'] = topics
                  else:
                      print("::error::Failed to load topics file")
              
              # Resolve other references
              print("Resolving all references...")
              try:
                  resolved_openapi = resolve_refs(openapi)
                  
                  # Write the resolved content to a new file
                  with open('openapi-resolved.yaml', 'w') as f:
                      yaml.dump(resolved_openapi, f, default_flow_style=False)
                  
                  print("Successfully created openapi-resolved.yaml")
                  
                  # Validate the resolved file is valid YAML
                  try:
                      with open('openapi-resolved.yaml', 'r') as f:
                          yaml.safe_load(f)
                      print("Verification: openapi-resolved.yaml is valid YAML")
                  except Exception as e:
                      print(f"::error::Generated file is not valid YAML: {str(e)}")
                      sys.exit(1)
                  
              except Exception as e:
                  print(f"::error::Failed to resolve references: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOL

          # Run the reference resolution script
          python3 resolve_refs.py

          # Check if the resolved file was created successfully
          if [ ! -f "openapi-resolved.yaml" ]; then
            echo "::error::Failed to create resolved OpenAPI file"
            exit 1
          fi

          # Print file size for verification
          echo "Original OpenAPI file size: $(wc -c openapi.yaml | awk '{print $1}') bytes"
          echo "Resolved OpenAPI file size: $(wc -c openapi-resolved.yaml | awk '{print $1}') bytes"

      - name: Deploy using Bump.sh CLI
        id: deploy
        run: |
          echo "Deploying to Bump.sh..."
          # Set a timeout to prevent hanging deployments
          timeout 180s bump deploy openapi-resolved.yaml --doc omni-v2 || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo "::error::Deployment timed out after 3 minutes"
              exit 1
            else
              echo "::error::Deployment failed with exit code $EXIT_CODE"
              exit $EXIT_CODE
            fi
          }

          echo "::notice::Successfully deployed to Bump.sh"
        env:
          BUMP_TOKEN: ${{ secrets.BUMP_TOKEN }}

      - name: Post-deployment validation
        if: always()
        run: |
          echo "Workflow completed with status: ${{ job.status }}"
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "View your documentation at: https://bump.sh/doc/omni-v2"
          else
            echo "Deployment failed. Check the logs for more information."
            
            # List files that might help with debugging
            echo "Files in repository:"
            find . -type f -name "*.yaml" -o -name "*.yml" | sort
          fi
