name: Deploy API Documentation to Bump.sh

on:
  push:
    branches: [main]
    paths:
      - '**/*.yaml'
      - '**/*.yml'
  workflow_dispatch:

jobs:
  deploy-to-bump:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for better context

      - name: Setup Node.js v20
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Bump.sh CLI
        run: |
          npm install -g bump-cli
          pip install --user pyyaml ruamel.yaml

      - name: Consolidate OpenAPI files
        id: consolidate
        run: |
          echo "Creating consolidated OpenAPI file..."
          cat > resolve_refs.py << 'EOL'
          import os
          import sys
          import re
          from ruamel.yaml import YAML
          from pathlib import Path

          # Use ruamel.yaml to preserve formatting
          yaml = YAML()
          yaml.preserve_quotes = True
          yaml.indent(mapping=2, sequence=4, offset=2)
          yaml.width = 80
          yaml.allow_unicode = True

          def load_yaml_safely(file_path):
              """Load a YAML file with error handling"""
              try:
                  with open(file_path, 'r') as f:
                      return yaml.load(f)
              except Exception as e:
                  print(f"Error loading {file_path}: {str(e)}")
                  return None

          def resolve_refs(openapi_content, base_dir='.'):
              """Recursively resolve all $ref references"""
              if isinstance(openapi_content, dict):
                  # Process $ref specially 
                  if '$ref' in openapi_content and isinstance(openapi_content['$ref'], str):
                      ref_value = openapi_content['$ref']
                      if not ref_value.startswith('#'):
                          # External reference
                          try:
                              # Split the reference into file path and internal reference
                              parts = ref_value.split('#', 1)
                              file_path = parts[0]
                              
                              # Handle relative paths
                              if file_path.startswith('./'):
                                  file_path = file_path[2:]
                              
                              # Combine with base directory
                              full_path = os.path.join(base_dir, file_path)
                              
                              print(f"Resolving: {ref_value}")
                              
                              # Load the referenced file
                              ref_content = load_yaml_safely(full_path)
                              if ref_content is None:
                                  print(f"Warning: Failed to resolve reference {ref_value}")
                                  return openapi_content  # Keep original reference
                              else:
                                  # If there's an internal reference, extract it
                                  if len(parts) > 1 and parts[1]:
                                      ref_path = parts[1].lstrip('/')
                                      try:
                                          # Navigate through the referenced content
                                          ref_parts = ref_path.split('/')
                                          current = ref_content
                                          for part in ref_parts:
                                              if part in current:
                                                  current = current[part]
                                              else:
                                                  print(f"Warning: Could not find {part} in {ref_path}")
                                                  return openapi_content  # Keep original
                                          
                                          # Replace with resolved content
                                          return resolve_refs(current, os.path.dirname(full_path))
                                      except Exception as e:
                                          print(f"Warning: Failed to resolve path {ref_path} in {full_path}: {e}")
                                          return openapi_content  # Keep original reference
                                  else:
                                      # Replace with entire file content
                                      return resolve_refs(ref_content, os.path.dirname(full_path))
                          except Exception as e:
                              print(f"Warning: Error resolving reference {ref_value}: {str(e)}")
                              return openapi_content  # Keep original reference
                      else:
                          # Internal reference, keep as is
                          return openapi_content
                  
                  # Create a new dict to avoid modifying while iterating
                  resolved_dict = type(openapi_content)()  # This preserves OrderedDict or dict type
                  for key, value in openapi_content.items():
                      resolved_dict[key] = resolve_refs(value, base_dir)
                  return resolved_dict
                  
              elif isinstance(openapi_content, list):
                  # Process lists recursively
                  return [resolve_refs(item, base_dir) for item in openapi_content]
              else:
                  # Return primitive values as is
                  return openapi_content

          def main():
              # Load main OpenAPI file
              print("Loading main OpenAPI file...")
              openapi = load_yaml_safely('openapi.yaml')
              if not openapi:
                  sys.exit(1)
              
              # Handle special case for x-topics separately
              if 'x-topics' in openapi:
                  if isinstance(openapi['x-topics'], dict) and '$ref' in openapi['x-topics']:
                      topics_ref = openapi['x-topics']['$ref']
                      print(f"Found x-topics reference: {topics_ref}")
                      
                      # Clean up the reference path
                      if topics_ref.startswith('./'):
                          topics_ref = topics_ref[2:]
                      
                      # Load topics file
                      topics = load_yaml_safely(topics_ref)
                      if topics:
                          print(f"Loaded topics file successfully")
                          openapi['x-topics'] = topics
                      else:
                          print("Error: Failed to load topics file")
              
              # Resolve other references
              print("Resolving references...")
              try:
                  resolved_openapi = resolve_refs(openapi)
                  
                  # Write the resolved content to a new file
                  with open('openapi-resolved.yaml', 'w') as f:
                      yaml.dump(resolved_openapi, f)
                  
                  print("Successfully created openapi-resolved.yaml with preserved formatting")
                  
              except Exception as e:
                  print(f"Error: Failed to resolve references: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOL

          # Run the reference resolution script
          python3 resolve_refs.py

          # Print file size for verification
          echo "Original OpenAPI file size: $(wc -c openapi.yaml | awk '{print $1}') bytes"
          echo "Resolved OpenAPI file size: $(wc -c openapi-resolved.yaml | awk '{print $1}') bytes"

      - name: Deploy to Bump.sh
        id: deploy
        run: |
          echo "Deploying to Bump.sh..."
          output=$(bump deploy openapi-resolved.yaml --doc omni-v2)
          EXIT_CODE=$?

          echo "$output"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "Deployment successful!"
          else
            if echo "$output" | grep -q "Your omni-v2 documentation has not changed"; then
              echo "No changes detected in documentation. Skipping deployment."
              exit 0
            else
              echo "Deployment failed with exit code $EXIT_CODE"
              exit $EXIT_CODE
            fi
          fi
        env:
          BUMP_TOKEN: ${{ secrets.BUMP_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "* Source file: openapi.yaml ($(wc -c openapi.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Resolved file: openapi-resolved.yaml ($(wc -c openapi-resolved.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Status: ${{ steps.deploy.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View documentation at: https://bump.sh/doc/omni-v2" >> $GITHUB_STEP_SUMMARY
