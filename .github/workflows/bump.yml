name: Deploy API Documentation to Bump.sh

on:
  push:
    branches: [main]
    paths:
      - '**/*.yaml'
      - '**/*.yml'
  workflow_dispatch:

jobs:
  deploy-to-bump:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for better context

      - name: Setup Node.js v20
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Bump.sh CLI
        run: |
          npm install -g bump-cli
          pip install --user pyyaml ruamel.yaml

      - name: Consolidate OpenAPI files
        id: consolidate
        run: |
          echo "Creating consolidated OpenAPI file..."
          cat > resolve_refs.py << 'EOL'
          import os
          import sys
          import re
          from ruamel.yaml import YAML
          from pathlib import Path
          from copy import deepcopy

          # Configure ruamel.yaml for best preservation of formatting
          yaml = YAML()
          yaml.preserve_quotes = True
          yaml.width = 4096  # Set a very large width to avoid line wrapping
          yaml.explicit_start = False  # Don't add '---' at the start of the file
          yaml.explicit_end = False    # Don't add '...' at the end of the file
          yaml.dump_all = False        # Don't use document separators

          # Preserve original formatting for scalar values, especially important for multi-line descriptions
          yaml.default_flow_style = False

          # Set very permissive white space handling
          yaml.allow_unicode = True

          # Keep literal and folding style in multiline strings
          yaml.emitter.best_width = -1
          yaml.indent(mapping=2, sequence=4, offset=2)

          def load_yaml_safely(file_path):
              """Load a YAML file with error handling"""
              try:
                  with open(file_path, 'r') as f:
                      return yaml.load(f)
              except Exception as e:
                  print(f"Error loading {file_path}: {str(e)}")
                  return None

          def find_external_refs(obj):
              """Find all external $ref pointers in the object"""
              refs = []
              
              def _traverse(current, path=""):
                  if isinstance(current, dict):
                      for k, v in current.items():
                          if k == '$ref' and isinstance(v, str) and not v.startswith('#'):
                              refs.append((path + "/" + k, v))
                          else:
                              _traverse(v, path + "/" + k if path else k)
                  elif isinstance(current, list):
                      for i, item in enumerate(current):
                          _traverse(item, f"{path}/{i}")
              
              _traverse(obj)
              return refs

          def resolve_ref(openapi, ref_path, ref_value, base_dir='.'):
              """Resolve a single reference and update the OpenAPI object"""
              try:
                  # Split the reference into file path and internal reference
                  parts = ref_value.split('#', 1)
                  file_path = parts[0]
                  
                  # Handle relative paths
                  if file_path.startswith('./'):
                      file_path = file_path[2:]
                  
                  # Combine with base directory
                  full_path = os.path.join(base_dir, file_path)
                  
                  print(f"Resolving reference: {ref_value}")
                  
                  # Load the referenced file
                  ref_content = load_yaml_safely(full_path)
                  if ref_content is None:
                      print(f"Warning: Failed to load referenced file {file_path}")
                      return False
                  
                  # If there's an internal reference, extract it
                  if len(parts) > 1 and parts[1]:
                      internal_path = parts[1].lstrip('/')
                      ref_parts = internal_path.split('/')
                      current = ref_content
                      
                      for part in ref_parts:
                          if part in current:
                              current = current[part]
                          else:
                              print(f"Warning: Could not resolve internal path {internal_path} in {file_path}")
                              return False
                      
                      # Find the target location to update
                      path_parts = ref_path.lstrip('/').split('/')
                      
                      # Remove the last part ('$ref')
                      path_parts = path_parts[:-1]
                      
                      # Navigate to the parent of the $ref
                      target = openapi
                      for part in path_parts:
                          if part.isdigit():  # Handle array indices
                              part = int(part)
                          target = target[part]
                      
                      # Replace the parent object with the resolved content
                      # but keep the $ref key for debugging
                      for k in list(target.keys()):
                          if k != '$ref':
                              del target[k]
                      
                      if isinstance(current, dict):
                          for k, v in current.items():
                              target[k] = deepcopy(v)
                      else:
                          # Special case for non-dict references
                          parent = openapi
                          for i, part in enumerate(path_parts[:-1]):
                              if part.isdigit():
                                  part = int(part)
                              parent = parent[part]
                          
                          last_part = path_parts[-1]
                          if last_part.isdigit():
                              last_part = int(last_part)
                          
                          parent[last_part] = deepcopy(current)
                  else:
                      # The reference is to the entire file
                      # Find the target location to update
                      path_parts = ref_path.lstrip('/').split('/')
                      
                      # Remove the last part ('$ref')
                      path_parts = path_parts[:-1]
                      
                      # Navigate to the parent of the $ref
                      parent = openapi
                      for i, part in enumerate(path_parts[:-1]):
                          if part.isdigit():
                              part = int(part)
                          parent = parent[part]
                      
                      last_part = path_parts[-1]
                      if last_part.isdigit():
                          last_part = int(last_part)
                      
                      # Replace the parent object with the resolved content
                      parent[last_part] = deepcopy(ref_content)
                  
                  return True
              except Exception as e:
                  print(f"Error resolving reference {ref_value}: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  return False

          def main():
              print("Loading main OpenAPI file...")
              openapi = load_yaml_safely('openapi.yaml')
              if not openapi:
                  sys.exit(1)
              
              # Handle special case for x-topics separately since it's often at the root level
              if 'x-topics' in openapi and isinstance(openapi['x-topics'], dict) and '$ref' in openapi['x-topics']:
                  topics_ref = openapi['x-topics']['$ref']
                  print(f"Found x-topics reference: {topics_ref}")
                  
                  # Clean up the reference path
                  if topics_ref.startswith('./'):
                      topics_ref = topics_ref[2:]
                  
                  # Load topics file
                  topics = load_yaml_safely(topics_ref)
                  if topics:
                      print(f"Loaded topics file successfully")
                      openapi['x-topics'] = topics
                  else:
                      print("Error: Failed to load topics file")
              
              # Find all other external references
              max_iterations = 10  # Prevent infinite loops
              iteration = 0
              
              while iteration < max_iterations:
                  iteration += 1
                  external_refs = find_external_refs(openapi)
                  
                  if not external_refs:
                      print(f"No more external references found after {iteration} iterations")
                      break
                  
                  print(f"Iteration {iteration}: Found {len(external_refs)} external references")
                  
                  # Resolve each reference
                  resolved_count = 0
                  for ref_path, ref_value in external_refs:
                      if resolve_ref(openapi, ref_path, ref_value):
                          resolved_count += 1
                  
                  print(f"Resolved {resolved_count}/{len(external_refs)} references")
                  
                  if resolved_count == 0:
                      print("No references were resolved in this iteration, stopping")
                      break
              
              # Write the resolved content to a new file
              try:
                  with open('openapi-resolved.yaml', 'w') as f:
                      yaml.dump(openapi, f)
                  
                  print("Successfully created openapi-resolved.yaml")
              except Exception as e:
                  print(f"Error writing resolved OpenAPI file: {str(e)}")
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOL

          # Run the reference resolution script
          python3 resolve_refs.py

          # Print file size for verification
          echo "Original OpenAPI file size: $(wc -c openapi.yaml | awk '{print $1}') bytes"
          echo "Resolved OpenAPI file size: $(wc -c openapi-resolved.yaml | awk '{print $1}') bytes"

      - name: Deploy to Bump.sh
        id: deploy
        run: |
          echo "Deploying to Bump.sh..."
          output=$(bump deploy openapi-resolved.yaml --doc omni-v2)
          EXIT_CODE=$?

          echo "$output"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "Deployment successful!"
          else
            if echo "$output" | grep -q "Your omni-v2 documentation has not changed"; then
              echo "No changes detected in documentation. Skipping deployment."
              exit 0
            else
              echo "Deployment failed with exit code $EXIT_CODE"
              exit $EXIT_CODE
            fi
          fi
        env:
          BUMP_TOKEN: ${{ secrets.BUMP_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "* Source file: openapi.yaml ($(wc -c openapi.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Resolved file: openapi-resolved.yaml ($(wc -c openapi-resolved.yaml | awk '{print $1}') bytes)" >> $GITHUB_STEP_SUMMARY
          echo "* Status: ${{ steps.deploy.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View documentation at: https://bump.sh/doc/omni-v2" >> $GITHUB_STEP_SUMMARY
